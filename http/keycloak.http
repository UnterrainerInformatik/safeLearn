###
# @name POST OWN attributes (different URL) (needs no additional realm-management role)
POST {{keycloakUrl}}/realms/{{realm}}/account
Authorization: openid password env
Content-Type: application/json

{
  "attributes": {
    "firstName": "Tea",
    "lastName": "Cher",
    "config": "custom value1",
    "lastVisitedUrl": "https://safelearn.unterrainer.info"
  }
}

###
# @name GET OWN attributes (different URL) (needs no additional realm-management role)
GET {{keycloakUrl}}/realms/{{realm}}/account
Authorization: openid password env
Content-Type: application/json

###

###
# @name GET all users
GET {{keycloakUrl}}/admin/realms/{{realm}}/users
Authorization: openid password env
Content-Type: application/json

###

### Benutzer holen, Fortschritt loggen, Liste am Ende ausgeben
GET {{keycloakUrl}}/admin/realms/{{realm}}/users?max=3
Authorization: openid password env
Accept: application/json

###

@max = 3000
### Benutzer abrufen mit Fortschrittsausgabe + reiner Namensliste
GET {{keycloakUrl}}/admin/realms/{{realm}}/users?max={{max}}
Authorization: openid password env
Accept: application/json

> {%
  console.log("==> Starte Abruf der Benutzer...");
  const t0 = Date.now();

  // Body ggf. parsen (abhängig von HTTP Yac-Version)
  let users;
  if (Array.isArray(response.body)) {
    users = response.body;
  } else if (typeof response.body === "string") {
    try {
      users = JSON.parse(response.body);
    } catch (e) {
      console.error("⚠️ Antwort ist kein gültiges JSON!");
      console.log(response.body);
      throw e;
    }
  } else {
    console.error("⚠️ Unerwarteter Typ von response.body:", typeof response.body);
    users = [];
  }

  console.log(`==> Abruf fertig: ${users.length} Benutzer (${((Date.now()-t0)/1000).toFixed(1)} s)`);

  // Filterfunktion für OU ----------
  const wantOu = "4CHIF";
  // --------------------------------
  function inTargetOu(u) {
    if (!wantOu) return true;
    const dn = u.attributes?.LDAP_ENTRY_DN?.[0] || "";
    return dn.includes(`,OU=${wantOu},`);
  }

  const total = users.length;
  const chunkSize = 100;
  console.log(`==> Verarbeite Benutzer in Blöcken von ${chunkSize}...`);
  let processed = 0;

  // Sammle als Objekte
  const people = [];

  for (let i = 0; i < total; i += chunkSize) {
    const chunk = users.slice(i, i + chunkSize);
    for (const u of chunk) {
      if (inTargetOu(u)) {
        const first = (u.firstName ?? "").trim();
        const last  = (u.lastName  ?? "").trim();
        if (first || last) {
          people.push({ firstName: first, lastName: last });
        }
      }
    }
    processed = Math.min(i + chunkSize, total);
    console.log(`   ... verarbeitet: ${processed}/${total}`);
  }

  console.log(`==> Fertig. Gefiltert: ${people.length} Einträge.`);
  if (wantOu) console.log(`==> OU-Filter aktiv: ${wantOu}`);

  // Sortiere: lastName → firstName (deutsche Sortierung, case-insensitive)
  people.sort((a, b) => {
    const ln = (a.lastName || "").localeCompare(b.lastName || "", "de", { sensitivity: "base" });
    if (ln !== 0) return ln;
    return (a.firstName || "").localeCompare(b.firstName || "", "de", { sensitivity: "base" });
  });

  console.log("\n=== KOPIERBARE LISTE ===");
  // Wenn dich das "INFO" stört, könntest du hier alternativ process.stdout.write verwenden.
  for (const o of people) {
    console.log(`@@@ ${o.firstName} ${o.lastName}`.trim());
    console.log("");
    console.log("@@@");
  }
%}

###
